# app/engine/__init__.py
"""
Template Engine - Architecture modulaire production-ready
"""
from .engine import TemplateEngine, get_engine, render
from .cache import CacheManager, CacheBackend, MemoryCache, RedisCache
from .filters import register_default_filters
from .helpers import register_default_helpers
from .mfe import MFEManager, MFEConfig
from .component import ComponentRegistry, auto_register_components

__version__ = "2.0.0"
__all__ = [
    "TemplateEngine",
    "get_engine", 
    "render",
    "CacheManager",
    "CacheBackend",
    "MemoryCache",
    "RedisCache",
    "MFEManager",
    "MFEConfig",
    "ComponentRegistry",
    "auto_register_components",
    "register_default_filters",
    "register_default_helpers"
]


# ==================== app/engine/cache.py ====================
"""
Cache management avec support multi-backend
"""
import time
import hashlib
import json
from abc import ABC, abstractmethod
from typing import Optional, Any
from threading import RLock
import logging

logger = logging.getLogger(__name__)


class CacheBackend(ABC):
    """Interface abstraite pour les backends de cache"""
    
    @abstractmethod
    def get(self, key: str) -> Optional[Any]:
        pass
    
    @abstractmethod
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        pass
    
    @abstractmethod
    def delete(self, key: str):
        pass
    
    @abstractmethod
    def clear(self):
        pass
    
    @abstractmethod
    def exists(self, key: str) -> bool:
        pass


class MemoryCache(CacheBackend):
    """Cache en mémoire thread-safe avec TTL"""
    
    def __init__(self):
        self._cache = {}
        self._timestamps = {}
        self._lock = RLock()
    
    def get(self, key: str, ttl: Optional[int] = None) -> Optional[Any]:
        with self._lock:
            if key not in self._cache:
                return None
            
            if ttl and key in self._timestamps:
                age = time.time() - self._timestamps[key]
                if age > ttl:
                    self.delete(key)
                    return None
            
            return self._cache[key]
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        with self._lock:
            self._cache[key] = value
            self._timestamps[key] = time.time()
    
    def delete(self, key: str):
        with self._lock:
            self._cache.pop(key, None)
            self._timestamps.pop(key, None)
    
    def clear(self):
        with self._lock:
            self._cache.clear()
            self._timestamps.clear()
    
    def exists(self, key: str) -> bool:
        with self._lock:
            return key in self._cache
    
    def size(self) -> int:
        """Nombre d'entrées dans le cache"""
        with self._lock:
            return len(self._cache)


class RedisCache(CacheBackend):
    """Cache Redis (optionnel)"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379", prefix: str = "template:"):
        try:
            import redis
            self.redis = redis.from_url(redis_url, decode_responses=True)
            self.prefix = prefix
            self.redis.ping()
            logger.info(f"Redis cache connected: {redis_url}")
        except ImportError:
            raise ImportError("redis package required. Install: pip install redis")
        except Exception as e:
            raise ConnectionError(f"Failed to connect to Redis: {e}")
    
    def _make_key(self, key: str) -> str:
        return f"{self.prefix}{key}"
    
    def get(self, key: str, ttl: Optional[int] = None) -> Optional[Any]:
        value = self.redis.get(self._make_key(key))
        return json.loads(value) if value else None
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        self.redis.set(
            self._make_key(key), 
            json.dumps(value, default=str),
            ex=ttl
        )
    
    def delete(self, key: str):
        self.redis.delete(self._make_key(key))
    
    def clear(self):
        for key in self.redis.scan_iter(f"{self.prefix}*"):
            self.redis.delete(key)
    
    def exists(self, key: str) -> bool:
        return self.redis.exists(self._make_key(key)) > 0


class CacheManager:
    """Gestionnaire de cache avec stratégies multiples"""
    
    def __init__(self, backend: Optional[CacheBackend] = None):
        self.backend = backend or MemoryCache()
        self.stats = {"hits": 0, "misses": 0}
    
    def get(self, key: str, ttl: Optional[int] = None) -> Optional[Any]:
        value = self.backend.get(key, ttl)
        if value is not None:
            self.stats["hits"] += 1
        else:
            self.stats["misses"] += 1
        return value
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None):
        self.backend.set(key, value, ttl)
    
    def delete(self, key: str):
        self.backend.delete(key)
    
    def clear(self):
        self.backend.clear()
        self.stats = {"hits": 0, "misses": 0}
    
    def exists(self, key: str) -> bool:
        return self.backend.exists(key)
    
    def get_stats(self) -> dict:
        """Statistiques de cache"""
        total = self.stats["hits"] + self.stats["misses"]
        hit_rate = (self.stats["hits"] / total * 100) if total > 0 else 0
        return {
            **self.stats,
            "total": total,
            "hit_rate": f"{hit_rate:.2f}%"
        }
    
    @staticmethod
    def make_key(*parts) -> str:
        """Générer une clé de cache"""
        key_str = ":".join(str(p) for p in parts)
        return hashlib.md5(key_str.encode()).hexdigest()


# ==================== app/engine/filters.py ====================
"""
Filtres Jinja2 personnalisés
"""
import re
import json
from datetime import datetime
from markupsafe import Markup
from typing import Any


def filter_truncate(text: str, length: int = 100, suffix: str = "...") -> str:
    """Tronquer le texte intelligemment"""
    if not text or len(text) <= length:
        return text
    
    truncated = text[:length].rsplit(' ', 1)[0]
    return truncated + suffix


def filter_slugify(text: str) -> str:
    """Convertir en slug URL-friendly"""
    text = text.lower().strip()
    text = re.sub(r'[àáâãäå]', 'a', text)
    text = re.sub(r'[èéêë]', 'e', text)
    text = re.sub(r'[ìíîï]', 'i', text)
    text = re.sub(r'[òóôõö]', 'o', text)
    text = re.sub(r'[ùúûü]', 'u', text)
    text = re.sub(r'[ýÿ]', 'y', text)
    text = re.sub(r'[ñ]', 'n', text)
    text = re.sub(r'[ç]', 'c', text)
    text = re.sub(r'[^\w\s-]', '', text)
    text = re.sub(r'[-\s]+', '-', text)
    return text.strip('-')


def filter_currency(value: float, symbol: str = "FCFA", position: str = "after") -> str:
    """Formater en devise"""
    formatted = f"{value:,.0f}".replace(",", " ")
    if position == "before":
        return f"{symbol} {formatted}"
    return f"{formatted} {symbol}"


def filter_timeago(dt: datetime, locale: str = "fr") -> str:
    """Temps relatif ('il y a X minutes')"""
    if not isinstance(dt, datetime):
        return str(dt)
    
    now = datetime.now()
    diff = now - dt
    seconds = diff.total_seconds()
    
    if locale == "fr":
        if seconds < 60:
            return "à l'instant"
        elif seconds < 3600:
            minutes = int(seconds / 60)
            return f"il y a {minutes} minute{'s' if minutes > 1 else ''}"
        elif seconds < 86400:
            hours = int(seconds / 3600)
            return f"il y a {hours} heure{'s' if hours > 1 else ''}"
        elif seconds < 604800:
            days = int(seconds / 86400)
            return f"il y a {days} jour{'s' if days > 1 else ''}"
        elif seconds < 2592000:
            weeks = int(seconds / 604800)
            return f"il y a {weeks} semaine{'s' if weeks > 1 else ''}"
        else:
            return dt.strftime("%d/%m/%Y")
    else:  # English
        if seconds < 60:
            return "just now"
        elif seconds < 3600:
            minutes = int(seconds / 60)
            return f"{minutes} minute{'s' if minutes != 1 else ''} ago"
        elif seconds < 86400:
            hours = int(seconds / 3600)
            return f"{hours} hour{'s' if hours != 1 else ''} ago"
        else:
            days = int(seconds / 86400)
            return f"{days} day{'s' if days != 1 else ''} ago"


def filter_json_safe(obj: Any) -> str:
    """JSON pour utilisation dans HTML"""
    return Markup(json.dumps(obj, ensure_ascii=False, default=str))


def filter_json_pretty(obj: Any) -> str:
    """JSON formaté avec indentation"""
    formatted = json.dumps(obj, indent=2, ensure_ascii=False, default=str)
    return Markup(f"<pre>{formatted}</pre>")


def filter_nl2br(text: str) -> str:
    """Convertir newlines en <br>"""
    return Markup(text.replace('\n', '<br>\n'))


def filter_pluralize(count: int, singular: str, plural: str = None) -> str:
    """Pluralisation intelligente"""
    if plural is None:
        plural = singular + "s"
    return singular if count == 1 else plural


def register_default_filters(env):
    """Enregistrer tous les filtres par défaut"""
    env.filters.update({
        "truncate": filter_truncate,
        "slugify": filter_slugify,
        "currency": filter_currency,
        "timeago": filter_timeago,
        "json": filter_json_safe,
        "json_pretty": filter_json_pretty,
        "nl2br": filter_nl2br,
        "pluralize": filter_pluralize,
    })


# ==================== app/engine/helpers.py ====================
"""
Fonctions helper globales
"""
import hashlib
import time
from datetime import datetime
from typing import List, Dict, Any, Optional
from starlette.requests import Request


def generate_csrf_token(request: Optional[Request] = None) -> str:
    """Générer un token CSRF"""
    if request and hasattr(request.state, 'csrf_token'):
        return request.state.csrf_token
    
    token = hashlib.sha256(f"{time.time()}".encode()).hexdigest()
    if request:
        request.state.csrf_token = token
    return token


def paginate(items: List, page: int = 1, per_page: int = 10) -> Dict[str, Any]:
    """Paginer une liste"""
    total = len(items)
    total_pages = max(1, (total + per_page - 1) // per_page)
    page = max(1, min(page, total_pages))
    
    start = (page - 1) * per_page
    end = start + per_page
    
    return {
        'items': items[start:end],
        'page': page,
        'per_page': per_page,
        'total': total,
        'total_pages': total_pages,
        'has_prev': page > 1,
        'has_next': page < total_pages,
        'prev_page': page - 1 if page > 1 else None,
        'next_page': page + 1 if page < total_pages else None,
        'start_index': start + 1 if items else 0,
        'end_index': min(end, total),
    }


def breadcrumbs(request: Optional[Request] = None) -> List[Dict[str, str]]:
    """Générer le fil d'Ariane"""
    if not request:
        return []
    
    path = request.url.path
    parts = [p for p in path.split('/') if p]
    
    crumbs = [{'name': 'Accueil', 'url': '/', 'active': len(parts) == 0}]
    current_path = ''
    
    for i, part in enumerate(parts):
        current_path += f'/{part}'
        is_last = i == len(parts) - 1
        
        crumbs.append({
            'name': part.replace('-', ' ').replace('_', ' ').title(),
            'url': current_path,
            'active': is_last
        })
    
    return crumbs


def asset_url(path: str, version: Optional[str] = None) -> str:
    """Générer URL d'asset avec version"""
    base_url = f"/static/{path}"
    if version:
        return f"{base_url}?v={version}"
    return base_url


def register_default_helpers(env):
    """Enregistrer tous les helpers par défaut"""
    env.globals.update({
        "csrf_token": generate_csrf_token,
        "paginate": paginate,
        "breadcrumbs": breadcrumbs,
        "now": datetime.now,
        "asset_url": asset_url,
    })


# ==================== app/engine/mfe.py ====================
"""
Micro-Frontend Manager avec circuit breaker
"""
import httpx
import logging
from typing import Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum
from time import time

logger = logging.getLogger(__name__)


class CircuitState(Enum):
    CLOSED = "closed"      # Normal
    OPEN = "open"          # Failures detected
    HALF_OPEN = "half_open"  # Testing recovery


@dataclass
class MFEConfig:
    """Configuration d'un MFE"""
    url: str
    timeout: float = 5.0
    max_retries: int = 2
    circuit_threshold: int = 5  # Failures before opening circuit
    circuit_timeout: int = 60   # Seconds before trying again


class CircuitBreaker:
    """Circuit breaker simple pour MFE"""
    
    def __init__(self, threshold: int = 5, timeout: int = 60):
        self.threshold = threshold
        self.timeout = timeout
        self.failures = 0
        self.last_failure_time = 0
        self.state = CircuitState.CLOSED
    
    def call_succeeded(self):
        """Marquer un appel réussi"""
        self.failures = 0
        self.state = CircuitState.CLOSED
    
    def call_failed(self):
        """Marquer un échec"""
        self.failures += 1
        self.last_failure_time = time()
        
        if self.failures >= self.threshold:
            self.state = CircuitState.OPEN
            logger.warning(f"Circuit breaker opened after {self.failures} failures")
    
    def can_attempt(self) -> bool:
        """Peut-on tenter un appel?"""
        if self.state == CircuitState.CLOSED:
            return True
        
        if self.state == CircuitState.OPEN:
            if time() - self.last_failure_time > self.timeout:
                self.state = CircuitState.HALF_OPEN
                logger.info("Circuit breaker half-open, testing recovery")
                return True
            return False
        
        return True  # HALF_OPEN


class MFEManager:
    """Gestionnaire de Micro-Frontends avec resilience"""
    
    def __init__(self):
        self.mfes: Dict[str, MFEConfig] = {}
        self.breakers: Dict[str, CircuitBreaker] = {}
        self.client: Optional[httpx.AsyncClient] = None
    
    def register(self, name: str, config: MFEConfig):
        """Enregistrer un MFE"""
        self.mfes[name] = config
        self.breakers[name] = CircuitBreaker(
            threshold=config.circuit_threshold,
            timeout=config.circuit_timeout
        )
        logger.info(f"Registered MFE '{name}' -> {config.url}")
    
    def register_simple(self, name: str, url: str, **kwargs):
        """Enregistrement simplifié"""
        config = MFEConfig(url=url, **kwargs)
        self.register(name, config)
    
    async def render(self, name: str, **params) -> str:
        """Render un MFE avec circuit breaker"""
        if name not in self.mfes:
            logger.warning(f"MFE '{name}' not registered")
            return f"<!-- MFE '{name}' not found -->"
        
        config = self.mfes[name]
        breaker = self.breakers[name]
        
        if not breaker.can_attempt():
            logger.warning(f"MFE '{name}' circuit breaker open")
            return f"<!-- MFE '{name}' temporarily unavailable -->"
        
        try:
            if not self.client:
                self.client = httpx.AsyncClient()
            
            response = await self.client.get(
                config.url,
                params=params,
                timeout=config.timeout
            )
            response.raise_for_status()
            
            breaker.call_succeeded()
            return response.text
            
        except httpx.TimeoutException:
            breaker.call_failed()
            logger.error(f"MFE '{name}' timeout after {config.timeout}s")
            return f"<!-- MFE '{name}' timeout -->"
            
        except httpx.HTTPError as e:
            breaker.call_failed()
            logger.error(f"MFE '{name}' HTTP error: {e}")
            return f"<!-- MFE '{name}' error -->"
            
        except Exception as e:
            breaker.call_failed()
            logger.exception(f"MFE '{name}' unexpected error")
            return f"<!-- MFE '{name}' error -->"
    
    async def close(self):
        """Fermer les connexions"""
        if self.client:
            await self.client.aclose()
            self.client = None